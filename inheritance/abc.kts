// 코틀린에서는 추상 클래스도 지원한다.

abstract class Musician(val name:String, val activeForm: Int) {
    abstract fun instrumentType(): String
}
// 자식 클래스인 Cellist의 주 생성자는 2개의 파라미터를 받은 후 베이스 클래스에게 넘갸준다.
// 베이스 클래스에서는 필요하지 않은 파라미터를 추가적으로 받을 수 있으며,
// 자식 클래스에서 추가적으로 받는 파라미터를 val 혹은 var로 선언하면 프로퍼티가 된다.
class Cellist(name: String, activeFrom: Int) : Musician(name, activeFrom) {
    override fun instrumentType() = "String"
}
val ma = Cellist("Yo-Yo Ma", 1961)

// 추상 클래스와 인터페이스의 주된 차이는 아래와 같다.
// 인터페이스에 정의된 속성에 백킹 필드가 없다. 인터페이스는 구현 클래스로부터 속성을 얻는 것을
// 추상 메소드에 의존한다. 반면에 추상 클래스는 백킹 필드를 지닌다.
// 인터페이스는 한 번에 여러 개를 구현할 수 있지만, 클래스는 추상 클래스든지 일반 클래스든지 하나만 확장 가능하다.

// 여러 클래스 사이에서 상태를 다시 사용해야 한다면 추상 클래스가 좋은 선택이다. 추상 클래스에서는 공통 상태를 구현할 수 있다.
// 그리고 클래스에서 추상 클래스가 제공해주는 상태를 재사용하며 메소드를 오버라이드 한다.

// 하나 이상의 명세와 요구사항을 만족하는 클래스들을 원하지만 각각의 클래스들이 각각의 구현을 하는 것을 원한다면
// 인터페이스가 좋은 선택이다.

// 모던 Java와 코틀린 양쪽에서 인터페이스가 추상 클래스보다 약간의 이점을 가지고 있다.
// 인터페이스는 메소드를 상태와 상관없이 구현할 수 있는 능력이 있다. 클래스는 여러 개의 인터페이스를 구현할 수 있다.
// 유연성을 위해서 가능하다면 추상 클래스나 베이스 클래스를 사용하는 것보다는 인터페이스를 사용하는 편이 좋다.