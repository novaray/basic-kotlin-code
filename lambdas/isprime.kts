//fun isPrime(n: Int) = n > 1 && (2 until n).none({i: Int -> n % i == 0})
/**
 * 코틀린이 파라미터에는 타입추론을 적용하지 않기 때문에 함수에 전달되는 각 파라미터의 타입이 필요하다.
 * 하지만 코틀린은 람다의 파라미터에는 타입을 필요로 하지 않는다.
 */
//fun isPrime(n: Int) = n > 1 && (2 until n).none({i -> n % i == 0})

/**
 * none()이 하나의 파라미터만 받기 때문에 괄호를 생략할 수 있다.
 */
fun isPrime(n: Int) = n > 1 && (2 until n).none { i -> n % i == 0 }

/**
 * 람다가 하나의 파라미터만 받는다면 파라미터 정의를 생략하고 it라는 이름의 특별한 암시적 파라미터를 사용할 수 있다.
 * 파라미터를 하나만 취하는 짧은 람다를 쓸 때는 파라미터 정의와 화살표를 생략하고 변수 이름으로 it를 사용하는 것이 좋다.
 * 이렇게 사용했을 때 유일한 단점은 파라미터가 없는 람다인지 아니면 it를 사용하여 파라미터 하나를 취하는 람다인지 빠르게 파악하기 어렵다는 점뿐이다.
 * 람다는 짧을 수록좋다. 여러 줄로 이루어진 람다는 유지보수하기 어렵기 때문이다.
 */
fun isPrime(n: Int) = n > 1 && (2 until n).none { n % it == 0 }

isPrime(7)